# 03 - JPA Entities

> Persistence layer: How Kotlin classes become PostgreSQL tables.

---

## 1. What is JPA and Hibernate?

**JPA (Jakarta Persistence API)** is a **specification** (a contract, like an interface) that defines how Java/Kotlin applications should interact with relational databases using objects. JPA **is not a library** that you execute directly: it is a set of annotations ([`@Entity`](https://jakarta.ee/specifications/persistence/3.2/), [`@Table`](https://jakarta.ee/specifications/persistence/3.2/), [`@Column`](https://jakarta.ee/specifications/persistence/3.2/)...) and rules that any implementation must follow.

**[Hibernate](https://hibernate.org/orm/documentation/)** is the most popular **implementation** of JPA. When Spring Boot starts with `spring-boot-starter-data-jpa`, it automatically includes Hibernate as an ORM (Object-Relational Mapping) engine. It is Hibernate that actually generates the SQL statements, manages the entity cache, and translates Kotlin objects into database rows.

```
Tu codigo Kotlin  --->  JPA (anotaciones)  --->  Hibernate (implementacion)  --->  SQL  --->  PostgreSQL
```

**Analogy**: JPA is like a Java interface, and Hibernate is the class that implements it. Your code only uses the interface (`jakarta.persistence.*` annotations), you never import anything from Hibernate directly. This gives you the theoretical freedom to change implementations without modifying your entities.

### Where is it configured in this project?

The dependency is on [`build.gradle.kts`](../../build.gradle.kts), line 27:

```kotlin
implementation("org.springframework.boot:spring-boot-starter-data-jpa")
```

This starter automatically includes:

- **Hibernate 7** (the version compatible with Spring Boot 4.0.2)
- **Spring Data JPA** (repositories, etc.)
- **Jakarta Persistence API** (the annotations `@Entity`, `@Column`, etc.)
- **HikariCP** (database connection pool)

---

## 2. Where is it used in this project?

The JPA entities are in package `model.entity`:

| Archive | Table in BD | ID | ID Type |
|---------|-------------|-----|-----------|
| [`src/main/kotlin/.../model/entity/WhoopCycle.kt`](../../src/main/kotlin/com/example/whoopdavidapi/model/entity/WhoopCycle.kt) | `whoop_cycles` | `id: Long` | Whoop API |
| [`src/main/kotlin/.../model/entity/WhoopRecovery.kt`](../../src/main/kotlin/com/example/whoopdavidapi/model/entity/WhoopRecovery.kt) | `whoop_recoveries` | `cycleId: Long` | Whoop API |
| [`src/main/kotlin/.../model/entity/WhoopSleep.kt`](../../src/main/kotlin/com/example/whoopdavidapi/model/entity/WhoopSleep.kt) | `whoop_sleeps` | `id: String` | Whoop API |
| [`src/main/kotlin/.../model/entity/WhoopWorkout.kt`](../../src/main/kotlin/com/example/whoopdavidapi/model/entity/WhoopWorkout.kt) | `whoop_workouts` | `id: String` | Whoop API |
| [`src/main/kotlin/.../model/entity/OAuthTokenEntity.kt`](../../src/main/kotlin/com/example/whoopdavidapi/model/entity/OAuthTokenEntity.kt) | `oauth_tokens` | `id: Long?` | Auto-generated by DB |

---

## 3. Why this decision?

### 3a. Why JPA and not direct JDBC or jOOQ?

- **Productivity**: With JPA, you don't manually write SQL for CRUD operations. You define a class and JPA generates the table and the queries.
- **Single User BFF Pattern**: This project syncs data from a single Whoop user. The queries are simple (filters by date, pagination). We don't need the flexibility of raw SQL that jOOQ offers.
- **Spring Ecosystem**: Spring Data JPA integrates natively with Spring Boot. Repositories, transactionality and pagination work "out of the box".

### 3b. Why `class` and not `data class` for entities?

JPA entities use `class` (not `data class`) for three reasons:

1. **Hibernate Proxies**: Hibernate needs to create proxies (subclasses) of your entities for lazy loading and dirty checking. The `data class` generate `equals()`, `hashCode()` and `copy()` based on **all** constructor fields, which interferes with the proxy mechanism.
2. **Identity vs equality**: Two objects `WhoopCycle` with the same `id` must be "the same entity" even if other fields differ (Hibernate may have the version partially loaded). The `equals()` of `data class` would fail in those cases.
3. **Mutability**: JPA needs `var` (mutables) to be able to set values ​​when loading from DB. `data class` work best with `val` (immutable).

### 3c. Why `var` fields with default values?

```kotlin
var id: Long = 0,           // Valor por defecto: 0
var scoreState: String = "PENDING_SCORE",  // Valor por defecto: string
var end: Instant? = null,   // Valor por defecto: null (nullable)
```

JPA/Hibernate requires a **no-argument constructor** to be able to instantiate entities when loading them from the DB. In Kotlin, by giving default values ​​to **all** parameters of the primary constructor, the compiler automatically generates a constructor with no arguments. This avoids having to write an empty secondary constructor.

---

## 4. Code explained

### 4a. Basic notations: `@Entity`, `@Table`, `@Id`, `@Column`

Let's analyze [`WhoopCycle.kt`](../../src/main/kotlin/com/example/whoopdavidapi/model/entity/WhoopCycle.kt):

```kotlin
package com.example.whoopdavidapi.model.entity

import jakarta.persistence.*       // Todas las anotaciones JPA
import java.time.Instant            // Tipo de timestamp timezone-safe

@Entity                              // (1) Marca esta clase como entidad JPA
@Table(name = "whoop_cycles")       // (2) Nombre de la tabla en la BD
class WhoopCycle(
    @Id                              // (3) Este campo es la clave primaria
    @Column(name = "id")             // (4) Nombre de la columna en la tabla
    var id: Long = 0,

    @Column(name = "user_id", nullable = false)  // (5) NOT NULL en la BD
    var userId: Long = 0,

    @Column(name = "created_at")
    var createdAt: Instant? = null,  // (6) Nullable en Kotlin = nullable en BD

    @Column(name = "updated_at")
    var updatedAt: Instant? = null,

    @Column(name = "start_time", nullable = false)
    var start: Instant = Instant.now(),

    @Column(name = "end_time")
    var end: Instant? = null,

    @Column(name = "timezone_offset")
    var timezoneOffset: String? = null,

    @Column(name = "score_state", nullable = false)
    var scoreState: String = "PENDING_SCORE",

    // Score fields (flattened)      // (7) Campos "aplanados"
    @Column(name = "strain")
    var strain: Float? = null,

    @Column(name = "kilojoule")
    var kilojoule: Float? = null,

    @Column(name = "average_heart_rate")
    var averageHeartRate: Int? = null,

    @Column(name = "max_heart_rate")
    var maxHeartRate: Int? = null
)
```

**Line by line explanation**:

| # | Annotation/Concept | What are you doing |
|---|---------------------|----------|
| (1) | `@Entity` | It tells JPA: "this class represents a table in the DB." Without this annotation, Hibernate ignores it completely. |
| (2) | `@Table(name = "whoop_cycles")` | Specifies the exact name of the table. Without it, JPA would use the class name (`WhoopCycle` -> `whoop_cycle`). We put it explicitly for clarity. |
| (3) | [`@Id`](https://jakarta.ee/specifications/persistence/3.2/) | Mark the field as **primary key**. Every JPA entity **must** have exactly one `@Id`. |
| (4) | `@Column(name = "id")` | Maps the Kotlin property to the column name in SQL. When the property name and column match, it is optional, but we include it to be explicit. |
| (5) | `nullable = false` | Generates `NOT NULL` in the DDL. Hibernate will throw an exception if you try to save a `null` in that field. |
| (6) | [`Instant`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/Instant.html)`?` (nullable in Kotlin) | Fields with `?` can be `null`. This aligns with the DB: `createdAt` may not exist if the data has not yet been processed by Whoop. |
| (7) | Score fields (flattened) | See section 4c below. |

### 4b. ID strategy: why it differs between entities

This is a key design point. There are **two different strategies**:

#### Strategy 1: ID assigned by Whoop API (WhoopCycle, WhoopRecovery, WhoopSleep, WhoopWorkout)

```kotlin
// WhoopCycle.kt
@Id
@Column(name = "id")
var id: Long = 0           // SIN @GeneratedValue --> el ID lo asignamos nosotros
```

```kotlin
// WhoopRecovery.kt
@Id
@Column(name = "cycle_id")
var cycleId: Long = 0      // El ID de recovery ES el cycle_id de Whoop
```

```kotlin
// WhoopSleep.kt
@Id
@Column(name = "id")
var id: String = ""         // El ID de sleep es un String (UUID de Whoop)
```

**Why?** This data comes from the Whoop API v2 with its own unique identifier. We use that same ID as the primary key in our database for two reasons:

1. **Idempotence in synchronization**: When the scheduler executes `repository.save(cycle)`, if the `id` already exists, JPA makes a `UPDATE` instead of a `INSERT`. This means we can re-sync data without creating duplicates.
2. **Traceability**: If you need to debug, you can search for the same ID in our database and in the Whoop API.

Note that **WhoopSleep** and **WhoopWorkout** use `String` as their ID type (they are UUIDs in the Whoop API), while **WhoopCycle** and **WhoopRecovery** use `Long`.

#### Strategy 2: ID auto-generated by the DB (OAuthTokenEntity)

```kotlin
// OAuthTokenEntity.kt
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
var id: Long? = null        // (A) Nullable porque aun no existe hasta el INSERT
```

**[`@GeneratedValue`](https://jakarta.ee/specifications/persistence/3.2/)`(strategy = GenerationType.IDENTITY)`**: Tells JPA that the database is responsible for generating the ID. In PostgreSQL, this uses a `BIGSERIAL` (auto-increment) column. In H2 (development), use `IDENTITY`.

**Why `Long?` (nullable)?** When you create a new `OAuthTokenEntity`, it doesn't have an ID yet:

```kotlin
val token = OAuthTokenEntity(
    accessToken = "eyJhbG...",  // id es null aqui
    refreshToken = "dGhpcw...",
    expiresAt = Instant.now().plusSeconds(3600)
)
oAuthTokenRepository.save(token)  // Ahora id tiene valor (ej: 1, 2, 3...)
```

**Why is this entity self-generating and the others NOT?** OAuth tokens do not come from the Whoop API with their own ID. They are internal data of our application. The DB decides the ID.

### 4c. "Flattened" layout: why there are no separate tables for scores

The Whoop API v2 returns nested data. For example, a cycle has:

```json
{
  "id": 12345,
  "user_id": 67890,
  "start": "2024-01-15T08:00:00Z",
  "score_state": "SCORED",
  "score": {
    "strain": 15.5,
    "kilojoule": 2500.0,
    "average_heart_rate": 72,
    "max_heart_rate": 185
  }
}
```

In a "pure" relational design, you would make two tables: `whoop_cycles` and `whoop_cycle_scores`, with a relation `@OneToOne`. We **flatten** those fields directly into the entity:

```kotlin
// En vez de @OneToOne a una tabla CycleScore:
@Column(name = "strain")
var strain: Float? = null,          // score.strain  -> columna directa

@Column(name = "kilojoule")
var kilojoule: Float? = null,       // score.kilojoule  -> columna directa

@Column(name = "average_heart_rate")
var averageHeartRate: Int? = null,   // score.average_heart_rate  -> columna directa

@Column(name = "max_heart_rate")
var maxHeartRate: Int? = null        // score.max_heart_rate  -> columna directa
```

**Why flatten?**

1. **Simplicity**: This is a BFF project for a single user. There are no millions of rows or complex queries. A flat table is easier to query in Power BI.
2. **Performance**: One `JOIN` less in each query. In Power BI, you connect a single table and you have all the data.
3. **Maintenance**: Fewer entities, fewer repositories, fewer mappers. The code is easier to understand.
4. **Strict 1:1 ratio**: A cycle has **exactly** one score (or none if it is `PENDING_SCORE`). There is no 1:N relationship that justifies a separate table.

The score fields are `nullable` (`Float?`, `Int?`) because when `scoreState = "PENDING_SCORE"`, there is still no score data.

Notice how this applies to all entities:

- **WhoopSleep**: Flattens `stage_summary` (8 fields like `totalInBedTimeMilli`, `totalRemSleepTimeMilli`) and `sleep_needed` (4 fields like `baselineMilli`, `needFromSleepDebtMilli`) directly into the table.
- **WhoopWorkout**: Flattens `score` (8 fields) and `zone_duration` (6 fields: `zoneZeroMilli` to `zoneFiveMilli`) directly.
- **WhoopRecovery**: Flattens `score` (6 fields: `recoveryScore`, `restingHeartRate`, `hrvRmssdMilli`, etc.).

### 4d. `@Convert` and token encryption: `EncryptedStringConverter` and `TokenEncryptor`

OAuth2 tokens are **sensitive data**. If someone accesses the DB, they should not be able to read the `accessToken` or the `refreshToken` in plain text. JPA offers [`@Convert`](https://jakarta.ee/specifications/persistence/3.2/) to automatically transform data when reading and writing.

At [`OAuthTokenEntity.kt`](../../src/main/kotlin/com/example/whoopdavidapi/model/entity/OAuthTokenEntity.kt):

```kotlin
@Column(name = "access_token", length = 4096)
@Convert(converter = EncryptedStringConverter::class)
var accessToken: String? = null,

@Column(name = "refresh_token", length = 4096)
@Convert(converter = EncryptedStringConverter::class)
var refreshToken: String? = null,
```

**`length = 4096`**: Encrypted tokens take up more space than the original ones. The calculation is:

- Original token: ~2KB max
- IV (12 bytes) + ciphertext + GCM tag (16 bytes) = ~2,028KB
- Base64 encoding adds 33% overhead = ~2.7KB
- Safety margin = 4096 bytes total

**`@Convert(converter = EncryptedStringConverter::class)`**: Every time JPA saves or reads this field, it goes through the converter.

The converter is at [`src/main/kotlin/.../util/EncryptedStringConverter.kt`](../../src/main/kotlin/com/example/whoopdavidapi/util/EncryptedStringConverter.kt):

```kotlin
@Converter                                                 // (1) Anotacion JPA
@Component                                                 // (2) Bean de Spring
class EncryptedStringConverter(
    private val encryptor: TokenEncryptor                   // (3) Inyeccion de dependencia
) : AttributeConverter<String?, String?> {                 // (4) Interface JPA

    override fun convertToDatabaseColumn(attribute: String?): String? {
        return encryptor.encrypt(attribute)                 // (5) Kotlin -> BD: cifra
    }

    override fun convertToEntityAttribute(dbData: String?): String? {
        return encryptor.decrypt(dbData)                    // (6) BD -> Kotlin: descifra
    }
}
```

| # | What are you doing |
|---|----------|
| (1) | `@Converter` marks this class as a JPA converter. |
| (2) | `@Component` registers it as a Spring bean, necessary for the injection of `TokenEncryptor` to work. |
| (3) | `TokenEncryptor` is another Spring component that contains the actual encryption logic. |
| (4) | `AttributeConverter<String?, String?>` is the JPA interface: transform `String?` (Kotlin type) to `String?` (BD type). |
| (5) | By doing `repository.save(entity)`, JPA calls `convertToDatabaseColumn`. The clear token is encrypted before reaching the DB. |
| (6) | By doing `repository.findById(id)`, JPA calls `convertToEntityAttribute`. The ciphertext is decrypted before reaching your code. |

**Full flow**:

```
Tu codigo: token.accessToken = "eyJhbGci..."
    |
    v  convertToDatabaseColumn()
    |
BD almacena: "Rk3mX2p...base64...cifrado..."
    |
    v  convertToEntityAttribute()
    |
Tu codigo recibe: "eyJhbGci..."  (transparente)
```

The actual encryption does [`src/main/kotlin/.../util/TokenEncryptor.kt`](../../src/main/kotlin/com/example/whoopdavidapi/util/TokenEncryptor.kt), which uses **[AES-256-GCM](https://en.wikipedia.org/wiki/Galois/Counter_Mode)**:

```kotlin
@Component
class TokenEncryptor(
    @Value("\${app.security.encryption-key:#{null}}") private val encryptionKey: String?
) {
    private val algorithm = "AES/GCM/NoPadding"
    private val keySpec: SecretKeySpec
    private val secureRandom = SecureRandom()

    companion object {
        private const val GCM_IV_LENGTH = 12    // 96 bits, recomendado para GCM
        private const val GCM_TAG_LENGTH = 128  // 128 bits, tag de autenticacion
    }

    init {
        // Falla al arrancar si no hay clave configurada
        require(!encryptionKey.isNullOrBlank()) {
            "app.security.encryption-key debe estar configurada."
        }

        // Decodifica la clave desde Base64
        val keyBytes = Base64.getDecoder().decode(encryptionKey)

        // Valida que sean exactamente 32 bytes (256 bits)
        require(keyBytes.size == 32) {
            "La clave debe representar exactamente 32 bytes (256 bits)."
        }

        keySpec = SecretKeySpec(keyBytes, "AES")
    }

    fun encrypt(plainText: String?): String? {
        if (plainText == null) return null
        val cipher = Cipher.getInstance(algorithm)
        val iv = ByteArray(GCM_IV_LENGTH)
        secureRandom.nextBytes(iv)                          // IV aleatorio cada vez
        val gcmSpec = GCMParameterSpec(GCM_TAG_LENGTH, iv)
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec)
        val encryptedBytes = cipher.doFinal(plainText.toByteArray(Charsets.UTF_8))
        val combined = iv + encryptedBytes                  // IV + ciphertext + GCM tag
        return Base64.getEncoder().encodeToString(combined)
    }

    fun decrypt(encryptedText: String?): String? {
        if (encryptedText == null) return null
        val combined = Base64.getDecoder().decode(encryptedText)
        val iv = combined.take(GCM_IV_LENGTH).toByteArray()
        val ciphertext = combined.drop(GCM_IV_LENGTH).toByteArray()
        val gcmSpec = GCMParameterSpec(GCM_TAG_LENGTH, iv)
        val cipher = Cipher.getInstance(algorithm)
        cipher.init(Cipher.DECRYPT_MODE, keySpec, gcmSpec)
        return String(cipher.doFinal(ciphertext), Charsets.UTF_8)
    }
}
```

**Key concepts of AES-256-GCM**:

- **AES-256**: Symmetric encryption algorithm with 256-bit key. "Simetric" = the same key encrypts and decrypts.
- **GCM (Galois/Counter Mode)**: Mode of operation that provides **confidentiality** (no one can read the text) AND **authenticity** (no one can modify the ciphertext without us detecting it). The 128-bit tag is like a digital signature of the encrypted content.
- **IV (Initialization Vector)**: 12 random bytes that are generated for **each encryption operation**. This ensures that encrypting the same text twice produces different results. The IV is stored along with the ciphertext (it is not secret).
- **NoPadding**: GCM does not need padding (unlike CBC), which simplifies implementation.

**Why does the key come from `application.yaml` and is not hardcoded?** Property `app.security.encryption-key` is configured as an environment variable or Kubernetes secret. It is never committed to the repository.

### 4e. The `allOpen` plugin and why it is necessary in Kotlin

In Kotlin, all  **classes are `final` by default** . This means they cannot be inherited (you cannot do `class Hijo : WhoopCycle()`). But Hibernate needs to create **proxies** of your entities, and the proxies are subclasses.

The `kotlin("plugin.jpa")` plugin (which includes [`allOpen`](https://kotlinlang.org/docs/all-open-plugin.html)) solves this. On [`build.gradle.kts`](../../build.gradle.kts):

```kotlin
plugins {
    kotlin("plugin.jpa") version "2.2.21"    // (1) Incluye allOpen para JPA
}

// ...

allOpen {                                     // (2) Configuracion explicita
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}
```

**What does this do?** When the Kotlin compiler encounters a class with `@Entity`, `@MappedSuperclass` or `@Embeddable`, it automatically makes it `open` (not final). So:

```kotlin
// Lo que TU escribes:
@Entity
class WhoopCycle(...)

// Lo que el COMPILADOR genera (gracias a allOpen):
@Entity
open class WhoopCycle(...)    // <-- ahora Hibernate puede crear proxies
```

Without this plugin, Hibernate would throw an error when trying to create proxies for final classes, or it would work in degraded mode without lazy loading.

### 4f. `java.time.Instant` for timestamps: why NOT use `Date` or `LocalDateTime`

All entities use `java.time.Instant` for temporary fields:

```kotlin
var createdAt: Instant? = null,
var updatedAt: Instant? = null,
var start: Instant = Instant.now(),
var end: Instant? = null,
var expiresAt: Instant = Instant.now(),
```

**Why `Instant` and not the alternatives?**

| Guy | Problem | Time zone? |
|------|----------|---------------|
| `java.util.Date` | Legacy API full of bugs, mutable, not thread-safe. Deprecated in practice. | Internally UTC, but the API is confusing. |
| `LocalDateTime` | **Does not have a time zone**. `2024-01-15T08:00:00` can be 8 AM in Madrid or Tokyo. Dangerous for data that crosses time zones. | NO |
| `OffsetDateTime` | Good option, but more complex than necessary for our case. | YES (fixed offset) |
| `Instant` | Exact point in time, always UTC. Simple, immutable, thread-safe. | YES (always UTC) |

**`Instant` is the best option for our case because:**

1. The Whoop API v2 returns timestamps in **ISO-8601 with UTC** (ex: `2024-01-15T08:00:00.000Z`). `Instant.parse()` reads them directly.
2. PostgreSQL stores `TIMESTAMP WITH TIME ZONE` in UTC internally. `Instant` maps to this type naturally.
3. Power BI can convert UTC to the dashboard's local time zone. The data in BD is always "the absolute truth."
4. The Whoop API includes a separate `timezone_offset` field (ex: `"-05:00"`), which we store as `String` in case Power BI needs it.

---

## 5. Official documentation

- [Jakarta Persistence API (JPA 3.2) Specification](https://jakarta.ee/specifications/persistence/3.2/)
- [Hibernate ORM 7 User Guide](https://docs.jboss.org/hibernate/orm/7.0/userguide/html_single/Hibernate_User_Guide.html)
- [Spring Data JPA Reference](https://docs.spring.io/spring-data/jpa/reference/)
- [Kotlin allOpen plugin](https://kotlinlang.org/docs/all-open-plugin.html)
- [java.time.Instant JavaDoc](https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/time/Instant.html)
- [AES-GCM (NIST SP 800-38D)](https://csrc.nist.gov/publications/detail/sp/800-38d/final)
- [JPA AttributeConverter JavaDoc](https://jakarta.ee/specifications/persistence/3.2/apidocs/jakarta.persistence/jakarta/persistence/attributeconverter)

---

> **Next**: [04 - Repositories](./04-repositorios.md) -- how Spring Data JPA automatically generates queries from method names.
