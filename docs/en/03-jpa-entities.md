# 03 - JPA Entities

> Persistence layer: how Kotlin classes are converted into PostgreSQL tables.

---

## 1. What are JPA and Hibernate?

**JPA (Jakarta Persistence API)** is a **specification** (a contract, like an interface) that defines how Java/Kotlin applications should interact with relational databases using objects. JPA **is not a library** that you run directly: it is a set of annotations ([`@Entity`](https://jakarta.ee/specifications/persistence/3.2/), [`@Table`](https://jakarta.ee/specifications/persistence/3.2/), [`@Column`](https://jakarta.ee/specifications/persistence/3.2/)...) and rules that any implementation must follow.

**[Hibernate](https://hibernate.org/orm/documentation/)** is the most popular **implementation** of JPA. When Spring Boot starts with `spring-boot-starter-data-jpa`, it automatically includes Hibernate as the ORM (Object-Relational Mapping) engine. It is Hibernate that actually generates the SQL statements, manages the entity cache, and translates Kotlin objects into database rows.

```
Tu codigo Kotlin  --->  JPA (anotaciones)  --->  Hibernate (implementacion)  --->  SQL  --->  PostgreSQL
```

**Analogy**: JPA is like a Java interface, and Hibernate is the class that implements it. Your code only uses the interface (`jakarta.persistence.*` annotations); you never import anything from Hibernate directly. This gives you the theoretical freedom to change implementations without modifying your entities.

### Where is it configured in this project?

The dependency is in [`build.gradle.kts`](../../build.gradle.kts), line 27:

```kotlin
implementation("org.springframework.boot:spring-boot-starter-data-jpa")
```

This starter automatically includes:

- **Hibernate 7** (the version compatible with Spring Boot 4.0.2)
- **Spring Data JPA** (repositories, etc.)
- **Jakarta Persistence API** (the annotations `@Entity`, `@Column`, etc.)
- **HikariCP** (database connection pool)

---

## 2. Where is it used in this project?

The JPA entities are in the `model.entity` package:

| File | Database table | ID | ID Type |
|---------|-------------|-----|-----------|
| [`src/main/kotlin/.../model/entity/WhoopCycle.kt`](../../src/main/kotlin/com/example/whoopdavidapi/model/entity/WhoopCycle.kt) | `whoop_cycles` | `id: Long` | Del Whoop API |
| [`src/main/kotlin/.../model/entity/WhoopRecovery.kt`](../../src/main/kotlin/com/example/whoopdavidapi/model/entity/WhoopRecovery.kt) | `whoop_recoveries` | `cycleId: Long` | Del Whoop API |
| [`src/main/kotlin/.../model/entity/WhoopSleep.kt`](../../src/main/kotlin/com/example/whoopdavidapi/model/entity/WhoopSleep.kt) | `whoop_sleeps` | `id: String` | From the Whoop API |
| [`src/main/kotlin/.../model/entity/WhoopWorkout.kt`](../../src/main/kotlin/com/example/whoopdavidapi/model/entity/WhoopWorkout.kt) | `whoop_workouts` | `id: String` | Del Whoop API |
| [`src/main/kotlin/.../model/entity/OAuthTokenEntity.kt`](../../src/main/kotlin/com/example/whoopdavidapi/model/entity/OAuthTokenEntity.kt) | `oauth_tokens` | `id: Long?` | Auto-generated by DB |

---

## 3. Why this decision?

### 3a. Why JPA and not direct JDBC or jOOQ?

- **Productivity**: With JPA, you don’t write SQL manually for CRUD operations. You define a class and JPA generates the table and the queries.
- **Single-user BFF pattern**: This project synchronizes data for a single Whoop user. The queries are simple (date filters, pagination). We don’t need the flexibility of raw SQL that jOOQ offers.
- **Spring ecosystem**: Spring Data JPA integrates natively with Spring Boot. Repositories, transaction management, and pagination work "out of the box".

### 3b. Why `class` and not `data class` for entities?

JPA entities use `class` (not `data class`) for three reasons:

1. **Hibernate Proxies**: Hibernate needs to create proxies (subclasses) of your entities for lazy loading and dirty checking. The `data class` generate `equals()`, `hashCode()`, and `copy()` based on **all** the constructor fields, which interferes with the proxy mechanism.
2. **Identity vs equality**: Two `WhoopCycle` objects with the same `id` must be "the same entity" even if other fields differ (Hibernate may have the partially loaded version). The `equals()` of `data class` would fail in those cases.
3. **Mutability**: JPA needs `var` (mutable) to be able to set values when loading from the DB. `data class` work better with `val` (immutable).

### 3c. Why fields `var` with default values?

```kotlin
var id: Long = 0,           // Valor por defecto: 0
var scoreState: String = "PENDING_SCORE",  // Valor por defecto: string
var end: Instant? = null,   // Valor por defecto: null (nullable)
```

JPA/Hibernate requires a **no-argument constructor** in order to instantiate entities when loading them from the DB. In Kotlin, by providing default values to **all** the parameters of the primary constructor, the compiler automatically generates a no-argument constructor. This avoids having to write an empty secondary constructor.

---

## 4. Explained code

### 4a. Basic annotations: `@Entity`, `@Table`, `@Id`, `@Column`

Let’s analyze [`WhoopCycle.kt`](../../src/main/kotlin/com/example/whoopdavidapi/model/entity/WhoopCycle.kt):

```kotlin
package com.example.whoopdavidapi.model.entity

import jakarta.persistence.*       // Todas las anotaciones JPA
import java.time.Instant            // Tipo de timestamp timezone-safe

@Entity                              // (1) Marca esta clase como entidad JPA
@Table(name = "whoop_cycles")       // (2) Nombre de la tabla en la BD
class WhoopCycle(
    @Id                              // (3) Este campo es la clave primaria
    @Column(name = "id")             // (4) Nombre de la columna en la tabla
    var id: Long = 0,

    @Column(name = "user_id", nullable = false)  // (5) NOT NULL en la BD
    var userId: Long = 0,

    @Column(name = "created_at")
    var createdAt: Instant? = null,  // (6) Nullable en Kotlin = nullable en BD

    @Column(name = "updated_at")
    var updatedAt: Instant? = null,

    @Column(name = "start_time", nullable = false)
    var start: Instant = Instant.now(),

    @Column(name = "end_time")
    var end: Instant? = null,

    @Column(name = "timezone_offset")
    var timezoneOffset: String? = null,

    @Column(name = "score_state", nullable = false)
    var scoreState: String = "PENDING_SCORE",

    // Score fields (flattened)      // (7) Campos "aplanados"
    @Column(name = "strain")
    var strain: Float? = null,

    @Column(name = "kilojoule")
    var kilojoule: Float? = null,

    @Column(name = "average_heart_rate")
    var averageHeartRate: Int? = null,

    @Column(name = "max_heart_rate")
    var maxHeartRate: Int? = null
)
```

**Line-by-line explanation**:

| # | Annotation/Concept | What does it do? |
|---|---------------------|----------|
| (1) | `@Entity` | It tells JPA: "this class represents a table in the DB." Without this annotation, Hibernate completely ignores it. |
| (2) | `@Table(name = "whoop_cycles")` | Specify the exact name of the table. Without it, JPA would use the class name (`WhoopCycle` -> `whoop_cycle`). We set it explicitly for clarity. |
| (3) | [`@Id`](https://jakarta.ee/specifications/persistence/3.2/) | Mark the field as **primary key**. Every JPA entity **must** have exactly one `@Id`. |
| (4) | `@Column(name = "id")` | Maps the Kotlin property to the column name in SQL. When the property name and the column name match, it is optional, but we include it to be explicit. |
| (5) | `nullable = false` | Generate `NOT NULL` in the DDL. Hibernate will throw an exception if you try to save a `null` in that field. |
| (6) | [`Instant`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/Instant.html)`?` (nullable in Kotlin) | Fields with `?` can be `null`. This aligns with the DB: `createdAt` may not exist if the data has not yet been processed by Whoop. |
| (7) | Score fields (flattened) | See section 4c below. |

### 4b. ID Strategy: why it differs between entities

This is a key design point. There are **two distinct strategies**:

#### Strategy 1: ID assigned by the Whoop API (WhoopCycle, WhoopRecovery, WhoopSleep, WhoopWorkout)

```kotlin
// WhoopCycle.kt
@Id
@Column(name = "id")
var id: Long = 0           // SIN @GeneratedValue --> el ID lo asignamos nosotros
```

```kotlin
// WhoopRecovery.kt
@Id
@Column(name = "cycle_id")
var cycleId: Long = 0      // El ID de recovery ES el cycle_id de Whoop
```

```kotlin
// WhoopSleep.kt
@Id
@Column(name = "id")
var id: String = ""         // El ID de sleep es un String (UUID de Whoop)
```

**Why?** This data comes from the Whoop API v2 with its own unique identifier. We use that same ID as the primary key in our DB for two reasons:

1. **Idempotency in synchronization**: When the scheduler runs `repository.save(cycle)`, if `id` already exists, JPA performs an `UPDATE` instead of an `INSERT`. This means we can re-synchronize data without creating duplicates.
2. **Traceability**: If you need to debug, you can look up the same ID in our DB and in the Whoop API.

Note that **WhoopSleep** and **WhoopWorkout** use `String` as the ID type (they are UUIDs in the Whoop API), while **WhoopCycle** and **WhoopRecovery** use `Long`.

#### Strategy 2: ID auto-generated by the DB (OAuthTokenEntity)

```kotlin
// OAuthTokenEntity.kt
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
var id: Long? = null        // (A) Nullable porque aun no existe hasta el INSERT
```

**[`@GeneratedValue`](https://jakarta.ee/specifications/persistence/3.2/)`(strategy = GenerationType.IDENTITY)`**: Tells JPA that the database is responsible for generating the ID. In PostgreSQL, this uses a `BIGSERIAL` column (auto-increment). In H2 (development), it uses `IDENTITY`.

**Why `Long?` (nullable)?** When you create a new `OAuthTokenEntity`, it still doesn't have an ID:

```kotlin
val token = OAuthTokenEntity(
    accessToken = "eyJhbG...",  // id es null aqui
    refreshToken = "dGhpcw...",
    expiresAt = Instant.now().plusSeconds(3600)
)
oAuthTokenRepository.save(token)  // Ahora id tiene valor (ej: 1, 2, 3...)
```

**Why does this entity auto-generate YES and the others NO?** OAuth tokens do not come from the Whoop API with their own ID. They are internal data of our application. The DB decides the ID.

### 4c. "Flattened" design: why there are no separate tables for scores

The Whoop API v2 returns nested data. For example, a cycle has:

```json
{
  "id": 12345,
  "user_id": 67890,
  "start": "2024-01-15T08:00:00Z",
  "score_state": "SCORED",
  "score": {
    "strain": 15.5,
    "kilojoule": 2500.0,
    "average_heart_rate": 72,
    "max_heart_rate": 185
  }
}
```

In a "pure" relational design, you would create two tables: `whoop_cycles` and `whoop_cycle_scores`, with a `@OneToOne` relationship. We **flatten** those fields directly into the entity:

```kotlin
// En vez de @OneToOne a una tabla CycleScore:
@Column(name = "strain")
var strain: Float? = null,          // score.strain  -> columna directa

@Column(name = "kilojoule")
var kilojoule: Float? = null,       // score.kilojoule  -> columna directa

@Column(name = "average_heart_rate")
var averageHeartRate: Int? = null,   // score.average_heart_rate  -> columna directa

@Column(name = "max_heart_rate")
var maxHeartRate: Int? = null        // score.max_heart_rate  -> columna directa
```

**Why flatten?**

1. **Simplicity**: This is a BFF project for a single user. There are not millions of rows or complex queries. A flat table is easier to query in Power BI.
2. **Performance**: One `JOIN` less in each query. In Power BI, you connect a single table and you have all the data.
3. **Maintenance**: Fewer entities, fewer repositories, fewer mappers. The code is easier to understand.
4. **Strict 1:1 relationship**: A cycle has **exactly** one score (or none if it is `PENDING_SCORE`). There is no 1:N relationship that would justify a separate table.

The score fields are `nullable` (`Float?`, `Int?`) because when `scoreState = "PENDING_SCORE"`, there is still no score data.

Observe how this applies across all entities:

- **WhoopSleep**: Flattens `stage_summary` (8 fields such as `totalInBedTimeMilli`, `totalRemSleepTimeMilli`) and `sleep_needed` (4 fields such as `baselineMilli`, `needFromSleepDebtMilli`) directly into the table.
- **WhoopWorkout**: Flatten `score` (8 fields) and `zone_duration` (6 fields: `zoneZeroMilli` to `zoneFiveMilli`) directly.
- **WhoopRecovery**: Flattens `score` (6 fields: `recoveryScore`, `restingHeartRate`, `hrvRmssdMilli`, etc.).

### 4d. `@Convert` and token encryption: `EncryptedStringConverter` and `TokenEncryptor`

OAuth2 tokens are **sensitive data**. If someone accesses the DB, they should not be able to read the `accessToken` or the `refreshToken` in plain text. JPA offers [`@Convert`](https://jakarta.ee/specifications/persistence/3.2/) to automatically transform data when reading and writing.

In [`OAuthTokenEntity.kt`](../../src/main/kotlin/com/example/whoopdavidapi/model/entity/OAuthTokenEntity.kt):

```kotlin
@Column(name = "access_token", length = 4096)
@Convert(converter = EncryptedStringConverter::class)
var accessToken: String? = null,

@Column(name = "refresh_token", length = 4096)
@Convert(converter = EncryptedStringConverter::class)
var refreshToken: String? = null,
```

**`length = 4096`**: Encrypted tokens take up more space than the original ones. The calculation is:

- Original token: ~2KB max
- IV (12 bytes) + ciphertext + GCM tag (16 bytes) = ~2.028KB
- Base64 encoding adds 33% overhead = ~2.7KB
- Safety margin = 4096 bytes total

**`@Convert(converter = EncryptedStringConverter::class)`**: Every time JPA saves or reads this field, it goes through the converter.

The converter is in [`src/main/kotlin/.../util/EncryptedStringConverter.kt`](../../src/main/kotlin/com/example/whoopdavidapi/util/EncryptedStringConverter.kt):

```kotlin
@Converter                                                 // (1) Anotacion JPA
@Component                                                 // (2) Bean de Spring
class EncryptedStringConverter(
    private val encryptor: TokenEncryptor                   // (3) Inyeccion de dependencia
) : AttributeConverter<String?, String?> {                 // (4) Interface JPA

    override fun convertToDatabaseColumn(attribute: String?): String? {
        return encryptor.encrypt(attribute)                 // (5) Kotlin -> BD: cifra
    }

    override fun convertToEntityAttribute(dbData: String?): String? {
        return encryptor.decrypt(dbData)                    // (6) BD -> Kotlin: descifra
    }
}
```

| # | What does it do? |
|---|----------|
| (1) | `@Converter` marks this class as a JPA converter. |
| (2) | `@Component` registers it as a Spring bean, necessary for `TokenEncryptor` injection to work. |
| (3) | `TokenEncryptor` is another Spring component that contains the actual encryption logic. |
| (4) | `AttributeConverter<String?, String?>` is the JPA interface: it transforms `String?` (Kotlin type) into `String?` (DB type). |
| (5) | When doing `repository.save(entity)`, JPA calls `convertToDatabaseColumn`. The plaintext token is encrypted before reaching the DB. |
| (6) | When doing `repository.findById(id)`, JPA calls `convertToEntityAttribute`. The ciphertext is decrypted before it reaches your code. |

**Complete flow**:

```
Tu codigo: token.accessToken = "eyJhbGci..."
    |
    v  convertToDatabaseColumn()
    |
BD almacena: "Rk3mX2p...base64...cifrado..."
    |
    v  convertToEntityAttribute()
    |
Tu codigo recibe: "eyJhbGci..."  (transparente)
```

The actual encryption is done by [`src/main/kotlin/.../util/TokenEncryptor.kt`](../../src/main/kotlin/com/example/whoopdavidapi/util/TokenEncryptor.kt), which uses **[AES-256-GCM](https://en.wikipedia.org/wiki/Galois/Counter_Mode)**:

```kotlin
@Component
class TokenEncryptor(
    @Value("\${app.security.encryption-key:#{null}}") private val encryptionKey: String?
) {
    private val algorithm = "AES/GCM/NoPadding"
    private val keySpec: SecretKeySpec
    private val secureRandom = SecureRandom()

    companion object {
        private const val GCM_IV_LENGTH = 12    // 96 bits, recomendado para GCM
        private const val GCM_TAG_LENGTH = 128  // 128 bits, tag de autenticacion
    }

    init {
        // Falla al arrancar si no hay clave configurada
        require(!encryptionKey.isNullOrBlank()) {
            "app.security.encryption-key debe estar configurada."
        }

        // Decodifica la clave desde Base64
        val keyBytes = Base64.getDecoder().decode(encryptionKey)

        // Valida que sean exactamente 32 bytes (256 bits)
        require(keyBytes.size == 32) {
            "La clave debe representar exactamente 32 bytes (256 bits)."
        }

        keySpec = SecretKeySpec(keyBytes, "AES")
    }

    fun encrypt(plainText: String?): String? {
        if (plainText == null) return null
        val cipher = Cipher.getInstance(algorithm)
        val iv = ByteArray(GCM_IV_LENGTH)
        secureRandom.nextBytes(iv)                          // IV aleatorio cada vez
        val gcmSpec = GCMParameterSpec(GCM_TAG_LENGTH, iv)
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec)
        val encryptedBytes = cipher.doFinal(plainText.toByteArray(Charsets.UTF_8))
        val combined = iv + encryptedBytes                  // IV + ciphertext + GCM tag
        return Base64.getEncoder().encodeToString(combined)
    }

    fun decrypt(encryptedText: String?): String? {
        if (encryptedText == null) return null
        val combined = Base64.getDecoder().decode(encryptedText)
        val iv = combined.take(GCM_IV_LENGTH).toByteArray()
        val ciphertext = combined.drop(GCM_IV_LENGTH).toByteArray()
        val gcmSpec = GCMParameterSpec(GCM_TAG_LENGTH, iv)
        val cipher = Cipher.getInstance(algorithm)
        cipher.init(Cipher.DECRYPT_MODE, keySpec, gcmSpec)
        return String(cipher.doFinal(ciphertext), Charsets.UTF_8)
    }
}
```

**Key concepts of AES-256-GCM**:

- **AES-256**: Symmetric encryption algorithm with a 256-bit key. "Symmetric" = the same key encrypts and decrypts.
- **GCM (Galois/Counter Mode)**: Mode of operation that provides **confidentiality** (no one can read the text) AND **authenticity** (no one can modify the ciphertext without us detecting it). The 128-bit "tag" is like a digital signature of the encrypted content.
- **IV (Initialization Vector)**: 12 random bytes that are generated for **each encryption operation**. This ensures that encrypting the same text twice produces different results. The IV is stored along with the ciphertext (it is not secret).
- **NoPadding**: GCM does not need padding (unlike CBC), which simplifies the implementation.

**Why does the key come from `application.yaml` and not hardcoded?** The `app.security.encryption-key` property is configured as an environment variable or Kubernetes secret. It is never committed to the repository.

### 4e. The `allOpen` plugin and why it is necessary in Kotlin

In Kotlin, **all classes are `final`final by default**. This means they cannot be inherited from (you can't do `class Hijo : WhoopCycle()`). But Hibernate needs to create **proxies** of your entities, and proxies are subclasses.

The `kotlin("plugin.jpa")` plugin (which includes [`allOpen`](https://kotlinlang.org/docs/all-open-plugin.html)) solves this. In [`build.gradle.kts`](../../build.gradle.kts):

```kotlin
plugins {
    kotlin("plugin.jpa") version "2.2.21"    // (1) Incluye allOpen para JPA
}

// ...

allOpen {                                     // (2) Configuracion explicita
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}
```

**What does this do?** When the Kotlin compiler finds a class with `@Entity`, `@MappedSuperclass`, or `@Embeddable`, it automatically makes it `open` (not final). Like this:

```kotlin
// Lo que TU escribes:
@Entity
class WhoopCycle(...)

// Lo que el COMPILADOR genera (gracias a allOpen):
@Entity
open class WhoopCycle(...)    // <-- ahora Hibernate puede crear proxies
```

Without this plugin, Hibernate would throw an error when trying to create proxies for final classes, or it would run in a degraded mode without lazy loading.

### 4f. `java.time.Instant` for timestamps: why NOT to use `Date` or `LocalDateTime`

All entities use `java.time.Instant` for temporal fields:

```kotlin
var createdAt: Instant? = null,
var updatedAt: Instant? = null,
var start: Instant = Instant.now(),
var end: Instant? = null,
var expiresAt: Instant = Instant.now(),
```

**Why `Instant` and not the alternatives?**

| Type | Problem | Time zone? |
|------|----------|---------------|
| `java.util.Date` | Legacy API full of bugs, mutable, not thread-safe. Deprecated in practice. | Internally UTC, but the API is confusing. |
| `LocalDateTime` | **It has no time zone**. `2024-01-15T08:00:00` could be 8 AM in Madrid or in Tokyo. Dangerous for data that crosses time zones. | NO |
| `OffsetDateTime` | A good option, but more complex than necessary for our case. | YES (fixed offset) |
| `Instant` | Exact point in time, always UTC. Simple, immutable, thread-safe. | YES (always UTC) |

**`Instant` is the best option for our case because:**

1. The Whoop API v2 returns timestamps in **ISO-8601 with UTC** (e.g., `2024-01-15T08:00:00.000Z`). `Instant.parse()` reads them directly.
2. PostgreSQL stores `TIMESTAMP WITH TIME ZONE` in UTC internally. `Instant` maps to this type naturally.
3. Power BI can convert UTC to the dashboard’s local time zone. The data in the database is always “the absolute truth.”
4. The Whoop API includes a separate `timezone_offset` field (e.g., `"-05:00"`), which we store as `String` in case Power BI needs it.

---

## 5. Official documentation

- [Jakarta Persistence API (JPA 3.2) Specification](https://jakarta.ee/specifications/persistence/3.2/)
- [Hibernate ORM 7 User Guide](https://docs.hibernate.org/orm/7.0/userguide/html_single/)
- [Spring Data JPA Reference](https://docs.spring.io/spring-data/jpa/reference/)
- [Kotlin allOpen plugin](https://kotlinlang.org/docs/all-open-plugin.html)
- [java.time.Instant JavaDoc](https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/time/Instant.html)
- [AES-GCM (NIST SP 800-38D)](https://csrc.nist.gov/pubs/sp/800/38/d/final)
- [JPA AttributeConverter JavaDoc](https://jakarta.ee/specifications/persistence/3.2/apidocs/jakarta.persistence/jakarta/persistence/attributeconverter)

---

> **Next**: [04 - Repositories](./04-repositorios.md) -- how Spring Data JPA automatically generates queries from method names.
